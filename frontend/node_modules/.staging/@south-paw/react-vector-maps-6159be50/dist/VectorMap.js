"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VectorMap = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var VectorMap = function VectorMap(_ref) {
  var id = _ref.id,
      name = _ref.name,
      layers = _ref.layers,
      tabIndex = _ref.tabIndex,
      layerProps = _ref.layerProps,
      checkedLayers = _ref.checkedLayers,
      currentLayers = _ref.currentLayers,
      other = _objectWithoutProperties(_ref, ["id", "name", "layers", "tabIndex", "layerProps", "checkedLayers", "currentLayers"]);

  if (!layers || !layers.length > 0) {
    console.error("[react-vector-maps] No 'layers' prop provided. Did you spread a map object onto the component?");
    return null;
  }

  return _react["default"].createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    key: id,
    "aria-label": name
  }, other), layers.map(function (layer) {
    return _react["default"].createElement("path", _extends({
      key: layer.id,
      tabIndex: tabIndex,
      "aria-label": layer.name,
      "aria-checked": checkedLayers && checkedLayers.includes(layer.id),
      "aria-current": currentLayers && currentLayers.includes(layer.id)
    }, layer, layerProps));
  }));
};

exports.VectorMap = VectorMap;
VectorMap.propTypes = {
  /** Unique ID of the SVG element. */
  id: _propTypes["default"].string.isRequired,

  /** Name of the map. */
  name: _propTypes["default"].string.isRequired,

  /** View box for the map. */
  viewBox: _propTypes["default"].string.isRequired,

  /** Layers that represent the regions of the map. */
  layers: _propTypes["default"].arrayOf(_propTypes["default"].shape({
    /** Unique ID of each layer. */
    id: _propTypes["default"].string.isRequired,

    /** Name of the layer. */
    name: _propTypes["default"].string,

    /** SVG path for the layer. */
    d: _propTypes["default"].string.isRequired
  })).isRequired,

  /** Tab index for each layer. Set to '-1' to disable layer focusing. */
  tabIndex: _propTypes["default"].number,

  /** Props to spread onto each layer. */
  layerProps: _propTypes["default"].object,

  /** Layer IDs to 'select' with the 'aria-checked' attribute. */
  checkedLayers: _propTypes["default"].arrayOf(_propTypes["default"].string),

  /** Layer IDs to 'select' with the 'aria-current' attribute. */
  currentLayers: _propTypes["default"].arrayOf(_propTypes["default"].string)
};
VectorMap.defaultProps = {
  tabIndex: 0,
  layerProps: null,
  checkedLayers: null,
  currentLayers: null
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9WZWN0b3JNYXAuanMiXSwibmFtZXMiOlsiVmVjdG9yTWFwIiwiaWQiLCJuYW1lIiwibGF5ZXJzIiwidGFiSW5kZXgiLCJsYXllclByb3BzIiwiY2hlY2tlZExheWVycyIsImN1cnJlbnRMYXllcnMiLCJvdGhlciIsImxlbmd0aCIsImNvbnNvbGUiLCJlcnJvciIsIm1hcCIsImxheWVyIiwiaW5jbHVkZXMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJpc1JlcXVpcmVkIiwidmlld0JveCIsImFycmF5T2YiLCJzaGFwZSIsImQiLCJudW1iZXIiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFNBQVMsR0FBRyxTQUFaQSxTQUFZLE9BQXdGO0FBQUEsTUFBckZDLEVBQXFGLFFBQXJGQSxFQUFxRjtBQUFBLE1BQWpGQyxJQUFpRixRQUFqRkEsSUFBaUY7QUFBQSxNQUEzRUMsTUFBMkUsUUFBM0VBLE1BQTJFO0FBQUEsTUFBbkVDLFFBQW1FLFFBQW5FQSxRQUFtRTtBQUFBLE1BQXpEQyxVQUF5RCxRQUF6REEsVUFBeUQ7QUFBQSxNQUE3Q0MsYUFBNkMsUUFBN0NBLGFBQTZDO0FBQUEsTUFBOUJDLGFBQThCLFFBQTlCQSxhQUE4QjtBQUFBLE1BQVpDLEtBQVk7O0FBQ3hHLE1BQUksQ0FBQ0wsTUFBRCxJQUFXLENBQUNBLE1BQU0sQ0FBQ00sTUFBUixHQUFpQixDQUFoQyxFQUFtQztBQUNqQ0MsSUFBQUEsT0FBTyxDQUFDQyxLQUFSO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FDRTtBQUFLLElBQUEsS0FBSyxFQUFDLDRCQUFYO0FBQXdDLElBQUEsR0FBRyxFQUFFVixFQUE3QztBQUFpRCxrQkFBWUM7QUFBN0QsS0FBdUVNLEtBQXZFLEdBQ0dMLE1BQU0sQ0FBQ1MsR0FBUCxDQUFXLFVBQUFDLEtBQUs7QUFBQSxXQUNmO0FBQ0UsTUFBQSxHQUFHLEVBQUVBLEtBQUssQ0FBQ1osRUFEYjtBQUVFLE1BQUEsUUFBUSxFQUFFRyxRQUZaO0FBR0Usb0JBQVlTLEtBQUssQ0FBQ1gsSUFIcEI7QUFJRSxzQkFBY0ksYUFBYSxJQUFJQSxhQUFhLENBQUNRLFFBQWQsQ0FBdUJELEtBQUssQ0FBQ1osRUFBN0IsQ0FKakM7QUFLRSxzQkFBY00sYUFBYSxJQUFJQSxhQUFhLENBQUNPLFFBQWQsQ0FBdUJELEtBQUssQ0FBQ1osRUFBN0I7QUFMakMsT0FNTVksS0FOTixFQU9NUixVQVBOLEVBRGU7QUFBQSxHQUFoQixDQURILENBREY7QUFlRCxDQXJCRDs7O0FBdUJBTCxTQUFTLENBQUNlLFNBQVYsR0FBc0I7QUFDcEI7QUFDQWQsRUFBQUEsRUFBRSxFQUFFZSxzQkFBVUMsTUFBVixDQUFpQkMsVUFGRDs7QUFHcEI7QUFDQWhCLEVBQUFBLElBQUksRUFBRWMsc0JBQVVDLE1BQVYsQ0FBaUJDLFVBSkg7O0FBS3BCO0FBQ0FDLEVBQUFBLE9BQU8sRUFBRUgsc0JBQVVDLE1BQVYsQ0FBaUJDLFVBTk47O0FBT3BCO0FBQ0FmLEVBQUFBLE1BQU0sRUFBRWEsc0JBQVVJLE9BQVYsQ0FDTkosc0JBQVVLLEtBQVYsQ0FBZ0I7QUFDZDtBQUNBcEIsSUFBQUEsRUFBRSxFQUFFZSxzQkFBVUMsTUFBVixDQUFpQkMsVUFGUDs7QUFHZDtBQUNBaEIsSUFBQUEsSUFBSSxFQUFFYyxzQkFBVUMsTUFKRjs7QUFLZDtBQUNBSyxJQUFBQSxDQUFDLEVBQUVOLHNCQUFVQyxNQUFWLENBQWlCQztBQU5OLEdBQWhCLENBRE0sRUFTTkEsVUFqQmtCOztBQWtCcEI7QUFDQWQsRUFBQUEsUUFBUSxFQUFFWSxzQkFBVU8sTUFuQkE7O0FBb0JwQjtBQUNBbEIsRUFBQUEsVUFBVSxFQUFFVyxzQkFBVVEsTUFyQkY7O0FBc0JwQjtBQUNBbEIsRUFBQUEsYUFBYSxFQUFFVSxzQkFBVUksT0FBVixDQUFrQkosc0JBQVVDLE1BQTVCLENBdkJLOztBQXdCcEI7QUFDQVYsRUFBQUEsYUFBYSxFQUFFUyxzQkFBVUksT0FBVixDQUFrQkosc0JBQVVDLE1BQTVCO0FBekJLLENBQXRCO0FBNEJBakIsU0FBUyxDQUFDeUIsWUFBVixHQUF5QjtBQUN2QnJCLEVBQUFBLFFBQVEsRUFBRSxDQURhO0FBRXZCQyxFQUFBQSxVQUFVLEVBQUUsSUFGVztBQUd2QkMsRUFBQUEsYUFBYSxFQUFFLElBSFE7QUFJdkJDLEVBQUFBLGFBQWEsRUFBRTtBQUpRLENBQXpCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmNvbnN0IFZlY3Rvck1hcCA9ICh7IGlkLCBuYW1lLCBsYXllcnMsIHRhYkluZGV4LCBsYXllclByb3BzLCBjaGVja2VkTGF5ZXJzLCBjdXJyZW50TGF5ZXJzLCAuLi5vdGhlciB9KSA9PiB7XG4gIGlmICghbGF5ZXJzIHx8ICFsYXllcnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtyZWFjdC12ZWN0b3ItbWFwc10gTm8gJ2xheWVycycgcHJvcCBwcm92aWRlZC4gRGlkIHlvdSBzcHJlYWQgYSBtYXAgb2JqZWN0IG9udG8gdGhlIGNvbXBvbmVudD9gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIga2V5PXtpZH0gYXJpYS1sYWJlbD17bmFtZX0gey4uLm90aGVyfT5cbiAgICAgIHtsYXllcnMubWFwKGxheWVyID0+IChcbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBrZXk9e2xheWVyLmlkfVxuICAgICAgICAgIHRhYkluZGV4PXt0YWJJbmRleH1cbiAgICAgICAgICBhcmlhLWxhYmVsPXtsYXllci5uYW1lfVxuICAgICAgICAgIGFyaWEtY2hlY2tlZD17Y2hlY2tlZExheWVycyAmJiBjaGVja2VkTGF5ZXJzLmluY2x1ZGVzKGxheWVyLmlkKX1cbiAgICAgICAgICBhcmlhLWN1cnJlbnQ9e2N1cnJlbnRMYXllcnMgJiYgY3VycmVudExheWVycy5pbmNsdWRlcyhsYXllci5pZCl9XG4gICAgICAgICAgey4uLmxheWVyfVxuICAgICAgICAgIHsuLi5sYXllclByb3BzfVxuICAgICAgICAvPlxuICAgICAgKSl9XG4gICAgPC9zdmc+XG4gICk7XG59O1xuXG5WZWN0b3JNYXAucHJvcFR5cGVzID0ge1xuICAvKiogVW5pcXVlIElEIG9mIHRoZSBTVkcgZWxlbWVudC4gKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgLyoqIE5hbWUgb2YgdGhlIG1hcC4gKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAvKiogVmlldyBib3ggZm9yIHRoZSBtYXAuICovXG4gIHZpZXdCb3g6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgLyoqIExheWVycyB0aGF0IHJlcHJlc2VudCB0aGUgcmVnaW9ucyBvZiB0aGUgbWFwLiAqL1xuICBsYXllcnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICAvKiogVW5pcXVlIElEIG9mIGVhY2ggbGF5ZXIuICovXG4gICAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgICAgLyoqIE5hbWUgb2YgdGhlIGxheWVyLiAqL1xuICAgICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIC8qKiBTVkcgcGF0aCBmb3IgdGhlIGxheWVyLiAqL1xuICAgICAgZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIH0pLFxuICApLmlzUmVxdWlyZWQsXG4gIC8qKiBUYWIgaW5kZXggZm9yIGVhY2ggbGF5ZXIuIFNldCB0byAnLTEnIHRvIGRpc2FibGUgbGF5ZXIgZm9jdXNpbmcuICovXG4gIHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKiogUHJvcHMgdG8gc3ByZWFkIG9udG8gZWFjaCBsYXllci4gKi9cbiAgbGF5ZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqIExheWVyIElEcyB0byAnc2VsZWN0JyB3aXRoIHRoZSAnYXJpYS1jaGVja2VkJyBhdHRyaWJ1dGUuICovXG4gIGNoZWNrZWRMYXllcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAvKiogTGF5ZXIgSURzIHRvICdzZWxlY3QnIHdpdGggdGhlICdhcmlhLWN1cnJlbnQnIGF0dHJpYnV0ZS4gKi9cbiAgY3VycmVudExheWVyczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG59O1xuXG5WZWN0b3JNYXAuZGVmYXVsdFByb3BzID0ge1xuICB0YWJJbmRleDogMCxcbiAgbGF5ZXJQcm9wczogbnVsbCxcbiAgY2hlY2tlZExheWVyczogbnVsbCxcbiAgY3VycmVudExheWVyczogbnVsbCxcbn07XG5cbmV4cG9ydCB7IFZlY3Rvck1hcCB9O1xuIl19