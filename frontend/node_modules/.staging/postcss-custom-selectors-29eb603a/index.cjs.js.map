{"version":3,"file":"index.cjs.js","sources":["lib/selectors-ast-from-selectors-string.js","lib/custom-selectors-from-root.js","lib/transform-selectors-by-custom-selectors.js","lib/transform-rules.js","lib/import-from.js","lib/export-to.js","index.js"],"sourcesContent":["import parser from 'postcss-selector-parser';\n\n/* Return a Selectors AST from a Selectors String\n/* ========================================================================== */\n\nexport default selectorString => {\n\tlet selectorAST;\n\n\tparser(selectors => {\n\t\tselectorAST = selectors\n\t}).processSync(selectorString);\n\n\treturn selectorAST;\n};\n","import getASTFromSelectors from './selectors-ast-from-selectors-string';\n\n// return custom selectors from the css root, conditionally removing them\nexport default (root, opts) => {\n\t// initialize custom selectors\n\tconst customSelectors = {};\n\n\t// for each custom selector atrule that is a child of the css root\n\troot.nodes.slice().forEach(node => {\n\t\tif (isCustomSelector(node)) {\n\t\t\t// extract the name and selectors from the params of the custom selector\n\t\t\tconst [, name, selectors] = node.params.match(customSelectorParamsRegExp);\n\n\t\t\t// write the parsed selectors to the custom selector\n\t\t\tcustomSelectors[name] = getASTFromSelectors(selectors);\n\n\t\t\t// conditionally remove the custom selector atrule\n\t\t\tif (!Object(opts).preserve) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn customSelectors;\n};\n\n// match the custom selector name\nconst customSelectorNameRegExp = /^custom-selector$/i;\n\n// match the custom selector params\nconst customSelectorParamsRegExp = /^(:--[A-z][\\w-]*)\\s+([\\W\\w]+)\\s*$/;\n\n// whether the atrule is a custom selector\nconst isCustomSelector = node => node.type === 'atrule' && customSelectorNameRegExp.test(node.name) && customSelectorParamsRegExp.test(node.params);\n","// return transformed selectors, replacing custom pseudo selectors with custom selectors\nexport default function transformSelectorList(selectorList, customSelectors) {\n\tlet index = selectorList.nodes.length - 1;\n\n\twhile (index >= 0) {\n\t\tconst transformedSelectors = transformSelector(selectorList.nodes[index], customSelectors);\n\n\t\tif (transformedSelectors.length) {\n\t\t\tselectorList.nodes.splice(index, 1, ...transformedSelectors);\n\t\t}\n\n\t\t--index;\n\t}\n\n\treturn selectorList;\n}\n\n// return custom pseudo selectors replaced with custom selectors\nfunction transformSelector(selector, customSelectors) {\n\tconst transpiledSelectors = [];\n\n\tfor (const index in selector.nodes) {\n\t\tconst { value, nodes } = selector.nodes[index];\n\n\t\tif (value in customSelectors) {\n\t\t\tfor (const replacementSelector of customSelectors[value].nodes) {\n\t\t\t\tconst selectorClone = selector.clone();\n\n\t\t\t\tselectorClone.nodes.splice(index, 1, ...replacementSelector.clone().nodes.map(node => {\n\t\t\t\t\t// use spacing from the current usage\n\t\t\t\t\tnode.spaces = { ...selector.nodes[index].spaces };\n\n\t\t\t\t\treturn node;\n\t\t\t\t}));\n\n\t\t\t\tconst retranspiledSelectors = transformSelector(selectorClone, customSelectors);\n\n\t\t\t\tadjustNodesBySelectorEnds(selectorClone.nodes, Number(index));\n\n\t\t\t\tif (retranspiledSelectors.length) {\n\t\t\t\t\ttranspiledSelectors.push(...retranspiledSelectors);\n\t\t\t\t} else {\n\t\t\t\t\ttranspiledSelectors.push(selectorClone);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn transpiledSelectors;\n\t\t} else if (nodes && nodes.length) {\n\t\t\ttransformSelectorList(selector.nodes[index], customSelectors);\n\t\t}\n\t}\n\n\treturn transpiledSelectors;\n}\n\n// match selectors by difficult-to-separate ends\nconst withoutSelectorStartMatch = /^(tag|universal)$/;\nconst withoutSelectorEndMatch = /^(class|id|pseudo|tag|universal)$/;\n\nconst isWithoutSelectorStart = node => withoutSelectorStartMatch.test(Object(node).type);\nconst isWithoutSelectorEnd = node => withoutSelectorEndMatch.test(Object(node).type);\n\n// adjust nodes by selector ends (so that .class:--h1 becomes h1.class rather than .classh1)\nconst adjustNodesBySelectorEnds = (nodes, index) => {\n\tif (index && isWithoutSelectorStart(nodes[index]) && isWithoutSelectorEnd(nodes[index - 1])) {\n\t\tlet safeIndex = index - 1;\n\n\t\twhile (safeIndex && isWithoutSelectorEnd(nodes[safeIndex])) {\n\t\t\t--safeIndex;\n\t\t}\n\n\t\tif (safeIndex < index) {\n\t\t\tconst node = nodes.splice(index, 1)[0];\n\n\t\t\tnodes.splice(safeIndex, 0, node);\n\n\t\t\tnodes[safeIndex].spaces.before = nodes[safeIndex + 1].spaces.before;\n\t\t\tnodes[safeIndex + 1].spaces.before = '';\n\n\t\t\tif (nodes[index]) {\n\t\t\t\tnodes[index].spaces.after = nodes[safeIndex].spaces.after;\n\t\t\t\tnodes[safeIndex].spaces.after = '';\n\t\t\t}\n\t\t}\n\t}\n};\n\n","import parser from 'postcss-selector-parser';\nimport transformSelectorsByCustomSelectors from './transform-selectors-by-custom-selectors';\n\n// transform custom pseudo selectors with custom selectors\nexport default (root, customSelectors, opts) => {\n\troot.walkRules(customPseudoRegExp, rule => {\n\t\tconst selector = parser(selectors => {\n\t\t\ttransformSelectorsByCustomSelectors(selectors, customSelectors, opts)\n\t\t}).processSync(rule.selector);\n\n\t\tif (opts.preserve) {\n\t\t\trule.cloneBefore({ selector });\n\t\t} else {\n\t\t\trule.selector = selector;\n\t\t}\n\t});\n};\n\nconst customPseudoRegExp = /:--[A-z][\\w-]*/;\n","import fs from 'fs';\nimport path from 'path';\nimport postcss from 'postcss';\nimport getSelectorsAstFromSelectorsString from './selectors-ast-from-selectors-string';\nimport getCustomSelectors from './custom-selectors-from-root';\n\n/* Import Custom Selectors from CSS AST\n/* ========================================================================== */\n\nfunction importCustomSelectorsFromCSSAST(root) {\n\treturn getCustomSelectors(root);\n}\n\n/* Import Custom Selectors from CSS File\n/* ========================================================================== */\n\nasync function importCustomSelectorsFromCSSFile(from) {\n\tconst css = await readFile(path.resolve(from));\n\tconst root = postc